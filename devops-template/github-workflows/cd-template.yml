name: CD - Deploy to Kubernetes

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - dev
          - staging
          - prod
      image-tag:
        description: 'Docker Image Tag (leave empty for latest)'
        required: false
        type: string
      deploy-backend:
        description: 'Deploy Backend'
        required: true
        default: true
        type: boolean
      deploy-frontend:
        description: 'Deploy Frontend'
        required: true
        default: true
        type: boolean
      run-smoke-tests:
        description: 'Run Smoke Tests After Deployment'
        required: true
        default: true
        type: boolean
  
  workflow_run:
    workflows: ["CI - Build and Push Images"]
    types:
      - completed
    branches: [main]

env:
  REGISTRY: ghcr.io
  # TODO: Replace with your GitHub username/organization
  IMAGE_OWNER: YOUR_GITHUB_USERNAME
  # TODO: Replace with your repository name
  IMAGE_NAME: YOUR_REPO_NAME

jobs:
  # ===========================================
  # DEPLOYMENT JOB
  # ===========================================
  deploy:
    name: Deploy to ${{ inputs.environment || 'staging' }}
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    environment:
      name: ${{ inputs.environment || 'staging' }}
      url: ${{ steps.get-url.outputs.app_url }}
    
    outputs:
      backend-url: ${{ steps.get-url.outputs.backend_url }}
      frontend-url: ${{ steps.get-url.outputs.frontend_url }}
    
    steps:
    # ===========================================
    # SETUP
    # ===========================================
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Set environment variables
      id: set-env
      run: |
        # Determine environment
        if [ "${{ github.event_name }}" == "workflow_run" ]; then
          echo "ENVIRONMENT=staging" >> $GITHUB_OUTPUT
          echo "NAMESPACE=app-staging" >> $GITHUB_OUTPUT
        else
          echo "ENVIRONMENT=${{ inputs.environment }}" >> $GITHUB_OUTPUT
          echo "NAMESPACE=app-${{ inputs.environment }}" >> $GITHUB_OUTPUT
        fi
        
        # Set environment-specific variables
        case "${{ inputs.environment || 'staging' }}" in
          prod)
            echo "CLUSTER_NAME=prod-cluster" >> $GITHUB_OUTPUT
            echo "DOMAIN=app.example.com" >> $GITHUB_OUTPUT
            echo "REPLICAS=3" >> $GITHUB_OUTPUT
            ;;
          staging)
            echo "CLUSTER_NAME=staging-cluster" >> $GITHUB_OUTPUT
            echo "DOMAIN=staging.app.example.com" >> $GITHUB_OUTPUT
            echo "REPLICAS=2" >> $GITHUB_OUTPUT
            ;;
          dev)
            echo "CLUSTER_NAME=dev-cluster" >> $GITHUB_OUTPUT
            echo "DOMAIN=dev.app.example.com" >> $GITHUB_OUTPUT
            echo "REPLICAS=1" >> $GITHUB_OUTPUT
            ;;
        esac
    
    - name: Determine image tag
      id: determine-tag
      run: |
        if [ "${{ github.event_name }}" == "workflow_run" ]; then
          # Use tag from CI workflow
          SHORT_SHA=$(echo "${{ github.event.workflow_run.head_sha }}" | cut -c1-7)
          echo "IMAGE_TAG=run-${{ github.event.workflow_run.run_number }}-${SHORT_SHA}" >> $GITHUB_OUTPUT
        elif [ -n "${{ inputs.image-tag }}" ]; then
          # Use provided tag
          echo "IMAGE_TAG=${{ inputs.image-tag }}" >> $GITHUB_OUTPUT
        else
          # Use latest tag
          echo "IMAGE_TAG=latest" >> $GITHUB_OUTPUT
        fi
    
    - name: Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    # ===========================================
    # KUBERNETES SETUP
    # ===========================================
    - name: Install kubectl
      uses: azure/setup-kubectl@v3
      with:
        version: 'latest'
    
    - name: Install kustomize
      run: |
        curl -s "https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh" | bash
        sudo mv kustomize /usr/local/bin/
    
    # TODO: Configure your Kubernetes access method
    # Option 1: Using kubeconfig secret
    - name: Configure kubectl with kubeconfig
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets[format('KUBECONFIG_{0}', steps.set-env.outputs.ENVIRONMENT)] }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
    
    # Option 2: Using cloud provider (AWS EKS example)
    # - name: Configure AWS credentials
    #   uses: aws-actions/configure-aws-credentials@v4
    #   with:
    #     aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
    #     aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
    #     aws-region: us-east-1
    # 
    # - name: Update kubeconfig for EKS
    #   run: |
    #     aws eks update-kubeconfig --name ${{ steps.set-env.outputs.CLUSTER_NAME }} --region us-east-1
    
    # Option 3: Using cloud provider (GKE example)
    # - name: Authenticate to Google Cloud
    #   uses: google-github-actions/auth@v2
    #   with:
    #     credentials_json: ${{ secrets.GCP_SA_KEY }}
    # 
    # - name: Get GKE credentials
    #   uses: google-github-actions/get-gke-credentials@v2
    #   with:
    #     cluster_name: ${{ steps.set-env.outputs.CLUSTER_NAME }}
    #     location: us-central1
    
    - name: Verify cluster connection
      run: |
        kubectl cluster-info
        kubectl get nodes
    
    # ===========================================
    # CREATE NAMESPACE AND SECRETS
    # ===========================================
    - name: Create namespace
      run: |
        kubectl create namespace ${{ steps.set-env.outputs.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Create image pull secret
      run: |
        kubectl create secret docker-registry ghcr-secret \
          --namespace=${{ steps.set-env.outputs.NAMESPACE }} \
          --docker-server=${{ env.REGISTRY }} \
          --docker-username=${{ github.actor }} \
          --docker-password=${{ secrets.GITHUB_TOKEN }} \
          --dry-run=client -o yaml | kubectl apply -f -
    
    - name: Create application secrets
      run: |
        # TODO: Adjust secret names and values based on your application
        kubectl create secret generic app-secrets \
          --namespace=${{ steps.set-env.outputs.NAMESPACE }} \
          --from-literal=DATABASE_URL="${{ secrets[format('DATABASE_URL_{0}', steps.set-env.outputs.ENVIRONMENT)] }}" \
          --from-literal=JWT_SECRET="${{ secrets[format('JWT_SECRET_{0}', steps.set-env.outputs.ENVIRONMENT)] }}" \
          --from-literal=API_KEY="${{ secrets[format('API_KEY_{0}', steps.set-env.outputs.ENVIRONMENT)] }}" \
          --dry-run=client -o yaml | kubectl apply -f -
    
    # ===========================================
    # DEPLOY BACKEND
    # ===========================================
    - name: Deploy Backend
      if: ${{ (github.event_name == 'workflow_dispatch' && inputs.deploy-backend) || github.event_name == 'workflow_run' }}
      working-directory: ./devops/kubernetes/overlays/${{ steps.set-env.outputs.ENVIRONMENT }}
      run: |
        echo "Deploying backend with tag: ${{ steps.determine-tag.outputs.IMAGE_TAG }}"
        
        # Update image in kustomization
        kustomize edit set image \
          backend=${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}/backend:${{ steps.determine-tag.outputs.IMAGE_TAG }}
        
        # Apply manifests
        kustomize build . | kubectl apply -f -
        
        # Wait for rollout
        kubectl rollout status deployment/backend \
          -n ${{ steps.set-env.outputs.NAMESPACE }} \
          --timeout=300s
        
        # Verify deployment
        kubectl get pods -n ${{ steps.set-env.outputs.NAMESPACE }} -l app=backend
    
    # ===========================================
    # DEPLOY FRONTEND
    # ===========================================
    - name: Deploy Frontend
      if: ${{ (github.event_name == 'workflow_dispatch' && inputs.deploy-frontend) || github.event_name == 'workflow_run' }}
      working-directory: ./devops/kubernetes/overlays/${{ steps.set-env.outputs.ENVIRONMENT }}
      run: |
        echo "Deploying frontend with tag: ${{ steps.determine-tag.outputs.IMAGE_TAG }}"
        
        # Update image in kustomization
        kustomize edit set image \
          frontend=${{ env.REGISTRY }}/${{ env.IMAGE_OWNER }}/${{ env.IMAGE_NAME }}/frontend:${{ steps.determine-tag.outputs.IMAGE_TAG }}
        
        # Apply manifests
        kustomize build . | kubectl apply -f -
        
        # Wait for rollout
        kubectl rollout status deployment/frontend \
          -n ${{ steps.set-env.outputs.NAMESPACE }} \
          --timeout=300s
        
        # Verify deployment
        kubectl get pods -n ${{ steps.set-env.outputs.NAMESPACE }} -l app=frontend
    
    # ===========================================
    # GET DEPLOYMENT URLS
    # ===========================================
    - name: Get application URLs
      id: get-url
      run: |
        # Get ingress information
        BACKEND_URL=$(kubectl get ingress backend-ingress -n ${{ steps.set-env.outputs.NAMESPACE }} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
        FRONTEND_URL=$(kubectl get ingress frontend-ingress -n ${{ steps.set-env.outputs.NAMESPACE }} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
        
        # If no ingress, try to get LoadBalancer service
        if [ -z "$BACKEND_URL" ]; then
          BACKEND_URL=$(kubectl get svc backend -n ${{ steps.set-env.outputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
        fi
        
        if [ -z "$FRONTEND_URL" ]; then
          FRONTEND_URL=$(kubectl get svc frontend -n ${{ steps.set-env.outputs.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
        fi
        
        # Set outputs
        echo "backend_url=https://${BACKEND_URL}" >> $GITHUB_OUTPUT
        echo "frontend_url=https://${FRONTEND_URL}" >> $GITHUB_OUTPUT
        echo "app_url=https://${FRONTEND_URL}" >> $GITHUB_OUTPUT
    
    # ===========================================
    # DEPLOYMENT SUMMARY
    # ===========================================
    - name: Create deployment summary
      run: |
        echo "## Deployment Summary 🚀" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### Environment: ${{ steps.set-env.outputs.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "**Namespace:** ${{ steps.set-env.outputs.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
        echo "**Image Tag:** ${{ steps.determine-tag.outputs.IMAGE_TAG }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "### Deployed Components" >> $GITHUB_STEP_SUMMARY
        echo "| Component | Status | URL |" >> $GITHUB_STEP_SUMMARY
        echo "|-----------|--------|-----|" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ inputs.deploy-backend || 'true' }}" == "true" ]; then
          echo "| Backend | ✅ Deployed | ${{ steps.get-url.outputs.backend_url }} |" >> $GITHUB_STEP_SUMMARY
        fi
        
        if [ "${{ inputs.deploy-frontend || 'true' }}" == "true" ]; then
          echo "| Frontend | ✅ Deployed | ${{ steps.get-url.outputs.frontend_url }} |" >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Resources" >> $GITHUB_STEP_SUMMARY
        kubectl get all -n ${{ steps.set-env.outputs.NAMESPACE }} >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # SMOKE TESTS
  # ===========================================
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy
    if: ${{ (github.event_name == 'workflow_dispatch' && inputs.run-smoke-tests) || github.event_name == 'workflow_run' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Wait for services to be ready
      run: sleep 30
    
    - name: Test backend health
      run: |
        echo "Testing backend at: ${{ needs.deploy.outputs.backend-url }}"
        curl -f -X GET "${{ needs.deploy.outputs.backend-url }}/health" || exit 1
    
    - name: Test frontend availability
      run: |
        echo "Testing frontend at: ${{ needs.deploy.outputs.frontend-url }}"
        curl -f -X GET "${{ needs.deploy.outputs.frontend-url }}" || exit 1
    
    - name: Run API smoke tests
      run: |
        # TODO: Add your API smoke tests here
        echo "Running API smoke tests..."
        
        # Example: Test authentication endpoint
        # curl -X POST "${{ needs.deploy.outputs.backend-url }}/api/auth/health" \
        #   -H "Content-Type: application/json" \
        #   -d '{"test": "data"}'
    
    - name: Create test summary
      if: always()
      run: |
        echo "## Smoke Test Results" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ "${{ job.status }}" == "success" ]; then
          echo "✅ **All smoke tests passed!**" >> $GITHUB_STEP_SUMMARY
        else
          echo "❌ **Some smoke tests failed. Please check the logs.**" >> $GITHUB_STEP_SUMMARY
        fi

  # ===========================================
  # ROLLBACK (Manual Trigger)
  # ===========================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && github.event_name == 'workflow_dispatch'
    needs: [deploy, smoke-tests]
    
    steps:
    - name: Configure kubectl
      run: |
        mkdir -p $HOME/.kube
        echo "${{ secrets[format('KUBECONFIG_{0}', inputs.environment)] }}" | base64 -d > $HOME/.kube/config
        chmod 600 $HOME/.kube/config
    
    - name: Rollback deployments
      run: |
        NAMESPACE="app-${{ inputs.environment }}"
        
        if [ "${{ inputs.deploy-backend }}" == "true" ]; then
          echo "Rolling back backend deployment..."
          kubectl rollout undo deployment/backend -n ${NAMESPACE}
          kubectl rollout status deployment/backend -n ${NAMESPACE} --timeout=300s
        fi
        
        if [ "${{ inputs.deploy-frontend }}" == "true" ]; then
          echo "Rolling back frontend deployment..."
          kubectl rollout undo deployment/frontend -n ${NAMESPACE}
          kubectl rollout status deployment/frontend -n ${NAMESPACE} --timeout=300s
        fi
        
        echo "⚠️ **Rollback completed**" >> $GITHUB_STEP_SUMMARY

  # ===========================================
  # CLEANUP OLD IMAGES
  # ===========================================
  cleanup-images:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    needs: deploy
    if: success()
    permissions:
      packages: write
    
    steps:
    - name: Delete old backend images
      uses: actions/delete-package-versions@v4
      with:
        package-name: '${{ env.IMAGE_NAME }}/backend'
        package-type: 'container'
        min-versions-to-keep: 10
        delete-only-untagged-versions: true
        token: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Delete old frontend images
      uses: actions/delete-package-versions@v4
      with:
        package-name: '${{ env.IMAGE_NAME }}/frontend'
        package-type: 'container'
        min-versions-to-keep: 10
        delete-only-untagged-versions: true
        token: ${{ secrets.GITHUB_TOKEN }}