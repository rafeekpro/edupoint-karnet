name: CD - Deploy to Kubernetes

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target Environment'
        required: true
        default: 'prod'
        type: choice
        options:
          - prod
      image-tag:
        description: 'Docker Image Tag (leave empty to use latest from main)'
        required: false
        type: string
      deploy-backend:
        description: 'Deploy Backend'
        required: true
        default: true
        type: boolean
      deploy-frontend:
        description: 'Deploy Frontend'
        required: true
        default: true
        type: boolean
      run-e2e-tests:
        description: 'Run E2E Tests'
        required: true
        default: true
        type: boolean
  
  workflow_run:
    workflows: ["🔨 CI - Build and Push Images"]
    types:
      - completed
    branches: [main]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  NAMESPACE: edupoint-prod

jobs:
  setup-vpn-and-deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    
    steps:
    # ===========================================
    # 📦 SETUP: Repository and Dependencies
    # ===========================================
    
    - name: 📦 Checkout repository
      uses: actions/checkout@v4
    
    - name: 🔐 Login to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: 🏷️ Determine image tag
      id: determine-tag
      run: |
        echo "📋 Triggered by: ${{ github.event_name }}"
        if [ "${{ github.event_name }}" == "workflow_run" ]; then
          echo "🔗 CI Workflow: ${{ github.event.workflow_run.name }}"
          echo "✅ CI Status: ${{ github.event.workflow_run.conclusion }}"
          echo "🆔 CI Run ID: ${{ github.event.workflow_run.id }}"
          # Get the tag from the CI workflow run (use short SHA)
          SHORT_SHA=$(echo "${{ github.event.workflow_run.head_sha }}" | cut -c1-7)
          echo "IMAGE_TAG=${{ github.event.workflow_run.id }}-${SHORT_SHA}" >> $GITHUB_OUTPUT
        elif [ -n "${{ inputs.image-tag }}" ]; then
          # Use the provided tag
          echo "IMAGE_TAG=${{ inputs.image-tag }}" >> $GITHUB_OUTPUT
        else
          # Get the latest available tag from the registry
          echo "📦 Fetching latest available tag..."
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          LATEST_TAG=$(gh api \
            -H "Accept: application/vnd.github+json" \
            /user/packages/container/edupoint-karnet%2Fbackend/versions \
            --jq '.[0].metadata.container.tags | .[] | select(. != "latest" and . != "main")' 2>/dev/null | head -1 || echo "")
          
          if [ -n "$LATEST_TAG" ]; then
            echo "IMAGE_TAG=$LATEST_TAG" >> $GITHUB_OUTPUT
            echo "✅ Using latest available tag: $LATEST_TAG"
          else
            # Fallback to main if no numbered tags found
            echo "IMAGE_TAG=main" >> $GITHUB_OUTPUT
            echo "⚠️ No numbered tags found, using 'main' as fallback"
          fi
        fi
        
        echo "Selected image tag: $(cat $GITHUB_OUTPUT | grep IMAGE_TAG | cut -d= -f2)"
    
    # ===========================================
    # 🔧 TOOLS: Install Required CLI Tools
    # ===========================================
    
    - name: 🔧 Install kubectl
      run: |
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x ./kubectl
        sudo mv ./kubectl /usr/local/bin/kubectl
        kubectl version --client
    
    # ===========================================
    # 🔐 VPN: Setup WireGuard Connection
    # ===========================================
    
    - name: 🔐 Install WireGuard
      run: |
        sudo apt-get update
        sudo apt-get install -y wireguard-tools resolvconf
    
    - name: 🌐 Configure WireGuard VPN
      run: |
        # Create WireGuard configuration
        echo "${{ secrets.WIREGUARD_CONFIG }}" | base64 -d | sudo tee /etc/wireguard/wg0.conf > /dev/null
        sudo chmod 600 /etc/wireguard/wg0.conf
        
        # Start WireGuard
        sudo wg-quick up wg0
        
        # Verify connection
        sudo wg show
        
        # Test connectivity
        ping -c 3 10.204.200.1 || echo "Cannot ping VPN gateway"
    
    # ===========================================
    # ☸️ KUBERNETES: Configure Access
    # ===========================================
    
    - name: ☸️ Configure kubectl
      run: |
        # Create .kube directory
        mkdir -p $HOME/.kube
        
        # Create kubeconfig directly
        cat > $HOME/.kube/config << EOF
        apiVersion: v1
        kind: Config
        clusters:
        - cluster:
            certificate-authority-data: ${{ secrets.K8S_CA_CERT }}
            insecure-skip-tls-verify: true
            # Użyj adresu IP serwera K8s dostępnego przez VPN
            server: https://10.204.200.1:6443
          name: default
        contexts:
        - context:
            cluster: default
            user: default
          name: default
        current-context: default
        users:
        - name: default
          user:
            client-certificate-data: ${{ secrets.K8S_CLIENT_CERT }}
            client-key-data: ${{ secrets.K8S_CLIENT_KEY }}
        EOF
        
        chmod 600 $HOME/.kube/config

    # ===========================================
    # 🔍 DIAGNOSTICS: Network and Connectivity
    # ===========================================
    
    - name: 🔍 Test network connectivity
      run: |
        echo "=== Network diagnostics ==="
        ip addr show
        ip route show
        echo "=== Testing connectivity ==="
        # Test połączenia VPN
        ping -c 3 10.204.200.1 || echo "Cannot ping VPN gateway"
        # Test połączenia z serwerem K8s przez VPN
        nc -zv 10.204.200.1 6443 || echo "Cannot connect to K8s API port"
        # Test API K8s z opcją -k, aby pominąć błędy certyfikatu
        curl -k https://10.204.200.1:6443/version || echo "Cannot reach K8s API"

    - name: ✅ Test kubectl connection
      run: |
        kubectl version --client
        # Teraz powinno działać, bo adres w kubeconfig jest poprawny
        kubectl cluster-info
        kubectl get namespaces 


    # ===========================================
    # 🚀 DEPLOYMENT PREPARATION
    # ===========================================
    
    - name: 🔒 Create GitHub Container Registry secret
      run: |
        kubectl create secret docker-registry ghcr-secret \
          --namespace=${{ env.NAMESPACE }} \
          --docker-server=${{ env.REGISTRY }} \
          --docker-username=${{ github.actor }} \
          --docker-password=${{ secrets.GITHUB_TOKEN }} \
          --dry-run=client -o yaml | kubectl apply -f -
    
    - name: 🌐 Install Traefik CRDs
      run: |
        # Check if Traefik CRDs are installed (check both old and new API versions)
        if ! kubectl get crd middlewares.traefik.io > /dev/null 2>&1; then
          echo "Installing Traefik CRDs..."
          kubectl apply -f https://raw.githubusercontent.com/traefik/traefik/v3.0/docs/content/reference/dynamic-configuration/kubernetes-crd-definition-v1.yml
        else
          echo "Traefik CRDs already installed"
        fi
    
    - name: 🔐 Create application secrets
      run: |
        kubectl delete secret edupoint-prod-secrets \
          --namespace=${{ env.NAMESPACE }} \
          --ignore-not-found=true
        
        kubectl create secret generic edupoint-prod-secrets \
          --namespace=${{ env.NAMESPACE }} \
          --from-literal=DB_PASSWORD="${{ secrets.DB_PASSWORD_PROD }}" \
          --from-literal=JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY_PROD }}"
    
    # ===========================================
    # 🎯 BACKEND DEPLOYMENT
    # ===========================================
    
    - name: 🎯 Deploy Backend
      if: ${{ (github.event_name == 'workflow_dispatch' && inputs.deploy-backend) || github.event_name == 'workflow_run' }}
      run: |
        cd devops/kubernetes/overlays/prod
        
        # Debug: Show available images
        echo "Looking for image tag: ${{ steps.determine-tag.outputs.IMAGE_TAG }}"
        
        # Verify image exists in registry
        IMAGE_URL="ghcr.io/${{ env.IMAGE_NAME }}/backend:${{ steps.determine-tag.outputs.IMAGE_TAG }}"
        echo "Verifying image: $IMAGE_URL"
        
        # Check if image exists
        if ! docker manifest inspect $IMAGE_URL 2>/dev/null; then
          echo "⚠️ Image with tag '${{ steps.determine-tag.outputs.IMAGE_TAG }}' not found!"
          echo "📦 Fetching available tags for backend..."
          
          # Method 1: Try using gh api with proper authentication
          echo "Method 1: GitHub API..."
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          AVAILABLE_TAGS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/user/packages/container/edupoint-karnet%2Fbackend/versions" \
            --jq '.[0:10] | .[] | .metadata.container.tags[]' 2>&1 | grep -v "^gh:" | grep -v "^  " | head -10 || echo "")
          
          # Method 2: If gh api fails, try using docker to list tags
          if [ -z "$AVAILABLE_TAGS" ]; then
            echo "Method 2: Docker registry catalog..."
            # Try to get catalog from registry (this might not work for ghcr.io)
            AVAILABLE_TAGS=$(curl -s -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://ghcr.io/v2/${{ github.repository }}/backend/tags/list" | \
              jq -r '.tags[]' 2>/dev/null | head -10 || echo "")
          fi
          
          # Method 3: Try common tag patterns
          if [ -z "$AVAILABLE_TAGS" ]; then
            echo "Method 3: Trying common tags..."
            for tag in "main" "latest" "main-${{ github.sha }}" "main-$(echo ${{ github.sha }} | cut -c1-7)"; do
              TEST_URL="ghcr.io/${{ env.IMAGE_NAME }}/backend:$tag"
              if docker manifest inspect $TEST_URL 2>/dev/null; then
                AVAILABLE_TAGS="$tag"
                echo "Found working tag: $tag"
                break
              fi
            done
          fi
          
          if [ -n "$AVAILABLE_TAGS" ]; then
            echo "Available tags:"
            echo "$AVAILABLE_TAGS"
            # Try to use the first available tag
            FIRST_TAG=$(echo "$AVAILABLE_TAGS" | head -1 | tr -d ' ')
            if [ -n "$FIRST_TAG" ]; then
              IMAGE_URL="ghcr.io/${{ env.IMAGE_NAME }}/backend:$FIRST_TAG"
              echo "📦 Trying available tag: $FIRST_TAG"
              if docker manifest inspect $IMAGE_URL 2>/dev/null; then
                echo "✅ Using available tag: $FIRST_TAG"
              else
                echo "ERROR: Could not use available tag!"
                exit 1
              fi
            else
              echo "ERROR: No usable tags found!"
              exit 1
            fi
          else
            echo "⚠️ Could not fetch tags, but will try to proceed with deployment anyway"
            echo "The image might exist even if we can't list tags"
          fi
        else
          echo "✅ Image found and verified!"
        fi
        
        # Clean up old resources
        echo "🧹 Cleaning up old resources..."
        kubectl delete secret edupoint-prod-secrets-7d4tmdc2bb -n ${{ env.NAMESPACE }} --ignore-not-found=true
        kubectl delete secret edupoint-secrets-mh7k42h6f7 -n ${{ env.NAMESPACE }} --ignore-not-found=true
        
        # Update image tag
        kustomize edit set image \
          ghcr.io/rafeekpro/edupoint-backend-prod=$IMAGE_URL
        
        # Build and apply
        kustomize build . | kubectl apply -f -
        
        # Wait for rollout with debug info
        kubectl rollout status deployment/edupoint-backend -n ${{ env.NAMESPACE }} --timeout=300s || {
          echo "Deployment failed, checking pod status..."
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=edupoint-backend
          echo "Checking pod events..."
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=edupoint-backend | tail -50
          echo "Checking pod logs..."
          kubectl logs -n ${{ env.NAMESPACE }} -l app=edupoint-backend --tail=50 || true
          exit 1
        }
    
    # ===========================================
    # 🌐 FRONTEND DEPLOYMENT  
    # ===========================================
    
    - name: 🌐 Deploy Frontend
      if: ${{ (github.event_name == 'workflow_dispatch' && inputs.deploy-frontend) || github.event_name == 'workflow_run' }}
      run: |
        cd devops/kubernetes/overlays/prod
        
        # Debug: Show available images
        echo "Looking for image tag: ${{ steps.determine-tag.outputs.IMAGE_TAG }}"
        
        # Verify image exists in registry
        IMAGE_URL="ghcr.io/${{ env.IMAGE_NAME }}/frontend:${{ steps.determine-tag.outputs.IMAGE_TAG }}"
        echo "Verifying image: $IMAGE_URL"
        
        # Check if image exists
        if ! docker manifest inspect $IMAGE_URL 2>/dev/null; then
          echo "⚠️ Image with tag '${{ steps.determine-tag.outputs.IMAGE_TAG }}' not found!"
          echo "📦 Fetching available tags for frontend..."
          
          # Method 1: Try using gh api with proper authentication
          echo "Method 1: GitHub API..."
          export GH_TOKEN="${{ secrets.GITHUB_TOKEN }}"
          AVAILABLE_TAGS=$(gh api \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "/user/packages/container/edupoint-karnet%2Ffrontend/versions" \
            --jq '.[0:10] | .[] | .metadata.container.tags[]' 2>&1 | grep -v "^gh:" | grep -v "^  " | head -10 || echo "")
          
          if [ -n "$AVAILABLE_TAGS" ]; then
            echo "$AVAILABLE_TAGS"
            # Try to use the first available tag
            FIRST_TAG=$(echo "$AVAILABLE_TAGS" | cut -d',' -f1 | tr -d ' ')
            if [ -n "$FIRST_TAG" ]; then
              IMAGE_URL="ghcr.io/${{ env.IMAGE_NAME }}/frontend:$FIRST_TAG"
              echo "📦 Trying first available tag: $FIRST_TAG"
              if docker manifest inspect $IMAGE_URL 2>/dev/null; then
                echo "✅ Using available tag: $FIRST_TAG"
              else
                echo "ERROR: Could not use available tag!"
                exit 1
              fi
            else
              echo "ERROR: No tags found!"
              exit 1
            fi
          else
            echo "ERROR: Could not fetch available tags!"
            exit 1
          fi
        else
          echo "✅ Image found and verified!"
        fi
        
        # Update image tag
        kustomize edit set image \
          ghcr.io/rafeekpro/edupoint-frontend-prod=$IMAGE_URL
        
        # Build and apply
        kustomize build . | kubectl apply -f -
        
        # Wait for rollout with debug info
        kubectl rollout status deployment/edupoint-frontend -n ${{ env.NAMESPACE }} --timeout=300s || {
          echo "Deployment failed, checking pod status..."
          kubectl get pods -n ${{ env.NAMESPACE }} -l app=edupoint-frontend
          echo "Checking pod events..."
          kubectl describe pods -n ${{ env.NAMESPACE }} -l app=edupoint-frontend | tail -50
          echo "Checking pod logs..."
          kubectl logs -n ${{ env.NAMESPACE }} -l app=edupoint-frontend --tail=50 || true
          exit 1
        }
    
    # ===========================================
    # ✅ VERIFICATION: Deployment Status
    # ===========================================
    
    - name: ✅ Verify deployment
      run: |
        echo "### Deployment Status" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "**Namespace:** ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
        echo "**Image Tag:** ${{ steps.determine-tag.outputs.IMAGE_TAG }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "#### Deployments:" >> $GITHUB_STEP_SUMMARY
        kubectl get deployments -n ${{ env.NAMESPACE }} >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "#### Pods:" >> $GITHUB_STEP_SUMMARY
        kubectl get pods -n ${{ env.NAMESPACE }} >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "#### Services:" >> $GITHUB_STEP_SUMMARY
        kubectl get services -n ${{ env.NAMESPACE }} >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        echo "#### Ingress:" >> $GITHUB_STEP_SUMMARY
        kubectl get ingress -n ${{ env.NAMESPACE }} >> $GITHUB_STEP_SUMMARY
    
    - name: Disconnect WireGuard
      if: always()
      run: |
        sudo wg-quick down wg0 || true

  run-e2e-tests:
    name: Run E2E Tests
    runs-on: ubuntu-latest
    needs: setup-vpn-and-deploy
    if: ${{ (github.event_name == 'workflow_dispatch' && inputs.run-e2e-tests) || github.event_name == 'workflow_run' }}
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
    
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '22'
    
    - name: Install dependencies
      run: |
        cd e2e-tests
        npm ci
        npx playwright install --with-deps
    
    - name: Run E2E tests
      run: |
        cd e2e-tests
        export BASE_URL=https://karnet.edupoint.pl
        export API_URL=https://karnetapi.edupoint.pl
        npm test
    
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: playwright-report
        path: e2e-tests/playwright-report/
        retention-days: 30